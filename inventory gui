-- [[ LOCAL SCRIPT: Inventory UI (Final System - Dynamic FOV + Always Count) ]]
-- TYPE: Client-Side UI Controller
-- FEATURES: Universal Glow, Dynamic Camera Restore, "x1" Display, Mobile Optimized
-- FIXED: Solved "no property named ImageColor3" console spam on TextButtons.

local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera
local openButton = script.Parent

-- ‚úÖ CRITICAL: GET PLAYER CONTROLS
local PlayerModule = require(player.PlayerScripts:WaitForChild("PlayerModule"))
local Controls = PlayerModule:GetControls()

-- ============================================================================
-- ‚öôÔ∏è CONFIGURATION
-- ============================================================================
local CONFIG = {
	FOV = {
		Open = 50,
		Default = 70 -- Fallback only, we now use Dynamic Capture
	},
	Zoom = { Min = 0.5, Max = 128 },
	Tween = TweenInfo.new(0.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
	Audio = {
		Click = "rbxassetid://9083627113",
		Equip = "rbxassetid://4676738150",
		Hover = "rbxassetid://6895079853",
		Mythic = "rbxassetid://9120048710",
		ShopMusic = "rbxassetid://83777726264435",
		GameThemeName = "GameTheme"
	},
	Colors = {
		Normal = Color3.fromRGB(255, 255, 255),
		Dim = Color3.fromRGB(150, 150, 150),
		Gold = Color3.fromRGB(255, 255, 100)
	},
	Images = {
		Default = "rbxassetid://132702954752503"
	}
}

-- ============================================================================
-- üìÇ HIERARCHY SETUP
-- ============================================================================
local myScreenGui = openButton:FindFirstAncestorWhichIsA("ScreenGui")
local mainWindow = myScreenGui:WaitForChild("InventoryWindow", 10)
local itemsContainer = mainWindow:WaitForChild("ItemContainer", 10)
local closeButton = mainWindow:WaitForChild("CloseButton", 10)

-- Tier Components
-- ‚úÖ FIX: TierFrame is now a child of InventoryWindow (mainWindow), not the ScreenGui
local tierFrame = mainWindow:WaitForChild("TierFrame", 10)
local tierContainer = tierFrame:WaitForChild("TierContainer", 10)

-- ‚úÖ EMPTY INDICATOR (ONLY ADDED FUNCTIONALITY)
-- ‚úÖ FIX: Use mainWindow directly (safer now that hierarchy is known)
local emptyIndicatorLabel = mainWindow:FindFirstChild("Indicator-v2", true)

local function updateEmptyIndicator(tierName, isEmpty)
	if not emptyIndicatorLabel then return end

	if isEmpty then
		emptyIndicatorLabel.Text = ("Your %s Stash is Empty"):format(tierName)
		emptyIndicatorLabel.Visible = true
		emptyIndicatorLabel.Active = false
	else
		emptyIndicatorLabel.Visible = false
		emptyIndicatorLabel.Active = false
	end
end

-- üîí STARTUP STATE
if mainWindow then mainWindow.Visible = false end
if tierFrame then tierFrame.Visible = false end
openButton.Visible = true
openButton.ImageColor3 = CONFIG.Colors.Normal

-- Music & Audio Setup
local gameThemeSound = SoundService:FindFirstChild(CONFIG.Audio.GameThemeName)
local shopMusic = Instance.new("Sound")
shopMusic.Name = "ShopMusic_Internal"
shopMusic.SoundId = CONFIG.Audio.ShopMusic
shopMusic.Volume = 0.5
shopMusic.Looped = true
shopMusic.Parent = SoundService

-- State Tracking
local currentFadeTween = nil
local hiddenGuis = {}
local currentTab = "Common"
local savedFOV = CONFIG.FOV.Default -- Variable to store user's FOV

-- üñºÔ∏è BACKGROUNDS MAP
local tierBackgrounds = {}
local tierNames = { "Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic" }

for _, rarity in ipairs(tierNames) do
	local bgObj = mainWindow:FindFirstChild(rarity .. "BG")
	if bgObj then
		tierBackgrounds[rarity] = bgObj
		bgObj.Visible = false
		if bgObj.ZIndex <= mainWindow.ZIndex then
			bgObj.ZIndex = mainWindow.ZIndex + 1
		end
	end
end

-- üìö MODULE LOADING
local CarStats = nil
local success, err = pcall(function()
	CarStats = require(ReplicatedStorage:WaitForChild("CarStats", 5))
end)
if not success then
	warn("‚ùå CRITICAL: CarStats failed to load. Inventory will not function.")
end

pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false) end)

-- ============================================================================
-- üõ†Ô∏è HELPER FUNCTIONS
-- ============================================================================
local function playSfx(soundId, volume)
	local s = Instance.new("Sound")
	s.SoundId = soundId
	s.Volume = volume or 0.5
	s.Parent = openButton
	s:Play()
	game.Debris:AddItem(s, 3)
end

local function getRarityColor(rarity)
	local map = {
		Common = Color3.fromRGB(180, 180, 180),
		Uncommon = Color3.fromRGB(50, 220, 50),
		Rare = Color3.fromRGB(50, 150, 255),
		Epic = Color3.fromRGB(180, 50, 255),
		Legendary = Color3.fromRGB(255, 180, 50),
		Mythic = Color3.fromRGB(255, 40, 40)
	}
	return map[rarity] or CONFIG.Colors.Normal
end

local function toggleOtherGuis(shouldHide)
	local playerGui = player:WaitForChild("PlayerGui")
	if shouldHide then
		hiddenGuis = {}
		for _, gui in pairs(playerGui:GetChildren()) do
			if gui:IsA("ScreenGui") and gui ~= myScreenGui and gui.Enabled == true then
				gui.Enabled = false
				table.insert(hiddenGuis, gui)
			end
		end
	else
		for _, gui in pairs(hiddenGuis) do
			if gui and gui.Parent then gui.Enabled = true end
		end
		hiddenGuis = {}
	end
end

-- ============================================================================
-- ‚ö° ANIMATION ENGINE (Universal Glow)
-- ============================================================================
local function ApplyUniversalGlow(textLabel, rarity)
	-- Cleanup
	for _, child in pairs(textLabel:GetChildren()) do
		if child:IsA("UIGradient") or child:IsA("UIStroke") then child:Destroy() end
	end

	textLabel.TextColor3 = Color3.new(1, 1, 1)

	-- Outline
	local stroke = Instance.new("UIStroke", textLabel)
	stroke.Thickness = 3
	stroke.Color = Color3.new(0, 0, 0)

	local gradient = Instance.new("UIGradient", textLabel)

	-- Color Logic
	if rarity == "Mythic" then
		gradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 0, 0)),
			ColorSequenceKeypoint.new(0.2, Color3.fromRGB(255, 255, 0)),
			ColorSequenceKeypoint.new(0.4, Color3.fromRGB(0, 255, 0)),
			ColorSequenceKeypoint.new(0.6, Color3.fromRGB(0, 255, 255)),
			ColorSequenceKeypoint.new(0.8, Color3.fromRGB(0, 0, 255)),
			ColorSequenceKeypoint.new(1.0, Color3.fromRGB(255, 0, 255))
		})
	elseif rarity == "Legendary" then
		gradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 180, 50)),
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 240, 150)),
			ColorSequenceKeypoint.new(1.0, Color3.fromRGB(255, 180, 50))
		})
		stroke.Color = Color3.fromRGB(100, 60, 0)
	elseif rarity == "Epic" then
		gradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0.0, Color3.fromRGB(160, 50, 255)),
			ColorSequenceKeypoint.new(1.0, Color3.fromRGB(220, 100, 255))
		})
		stroke.Color = Color3.fromRGB(60, 0, 100)
	elseif rarity == "Rare" then
		gradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0.0, Color3.fromRGB(0, 100, 255)),
			ColorSequenceKeypoint.new(1.0, Color3.fromRGB(100, 200, 255))
		})
	elseif rarity == "Uncommon" then
		gradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0.0, Color3.fromRGB(0, 180, 0)),
			ColorSequenceKeypoint.new(1.0, Color3.fromRGB(100, 255, 100))
		})
	else
		-- Common
		gradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0.0, Color3.fromRGB(150, 150, 150)),
			ColorSequenceKeypoint.new(1.0, Color3.fromRGB(220, 220, 220))
		})
	end

	-- Breathing Animation
	task.spawn(function()
		local speed = 3
		while textLabel.Parent do
			local t = tick()
			local shimmer = 0.2 + 0.2 * math.sin(t * speed)
			gradient.Transparency = NumberSequence.new(shimmer)
			RunService.Heartbeat:Wait()
		end
	end)
end

-- ============================================================================
-- üé® BUTTON INTERACTION
-- ============================================================================
local function addButtonEffects(btn, scaleOnly)
	local scale = btn:FindFirstChild("UIScale") or Instance.new("UIScale", btn)

	if not UserInputService.TouchEnabled then
		btn.MouseEnter:Connect(function()
			playSfx(CONFIG.Audio.Hover, 0.3)
			btn.ZIndex = 10
			TweenService:Create(scale, TweenInfo.new(0.2), { Scale = 1.1 }):Play()

			if not scaleOnly then
				local goals = { BackgroundColor3 = CONFIG.Colors.Dim }

				if btn:IsA("ImageButton") or btn:IsA("ImageLabel") then
					goals.ImageColor3 = CONFIG.Colors.Dim
				end

				TweenService:Create(btn, TweenInfo.new(0.2), goals):Play()
			end
		end)

		btn.MouseLeave:Connect(function()
			btn.ZIndex = 1
			TweenService:Create(scale, TweenInfo.new(0.2), { Scale = 1 }):Play()

			if not scaleOnly then
				local goals = { BackgroundColor3 = getRarityColor(btn.Name) }

				if btn:IsA("ImageButton") or btn:IsA("ImageLabel") then
					goals.ImageColor3 = CONFIG.Colors.Normal
				end

				TweenService:Create(btn, TweenInfo.new(0.2), goals):Play()
			end
		end)
	end
end

local function addOpenButtonHover(btn)
	if not UserInputService.TouchEnabled then
		btn.MouseEnter:Connect(function()
			playSfx(CONFIG.Audio.Hover, 0.3)
			TweenService:Create(btn, TweenInfo.new(0.2), { ImageColor3 = CONFIG.Colors.Dim }):Play()
		end)
		btn.MouseLeave:Connect(function()
			TweenService:Create(btn, TweenInfo.new(0.2), { ImageColor3 = CONFIG.Colors.Normal }):Play()
		end)
	end
end

local function updateBackground()
	for rarityKey, bgObject in pairs(tierBackgrounds) do
		bgObject.Visible = (rarityKey == currentTab)
	end
end

-- ============================================================================
-- üéí INVENTORY GENERATION (Always Show Count)
-- ============================================================================
local function updateInventory()
	for _, child in pairs(itemsContainer:GetChildren()) do
		if child:IsA("GuiObject") and not child:IsA("UIListLayout") and not child:IsA("UIGridLayout") then
			child:Destroy()
		end
	end

	local inventoryData = {}

	local function scan(loc)
		if not loc then return end
		for _, tool in pairs(loc:GetChildren()) do
			if tool:IsA("Tool") and CarStats and CarStats.Cars then
				local cleanName = nil
				if CarStats.Cars[tool.Name] then
					cleanName = tool.Name
				elseif tool.Name:match(" Item$") then
					cleanName = tool.Name:gsub(" Item", "")
				elseif tool.Name:match("Item$") then
					cleanName = tool.Name:gsub("Item", "")
				end

				if cleanName and CarStats.Cars[cleanName] then
					if inventoryData[cleanName] then
						inventoryData[cleanName].Count = inventoryData[cleanName].Count + 1
					else
						inventoryData[cleanName] = { Tool = tool, Count = 1 }
					end
				end
			end
		end
	end

	scan(player:FindFirstChild("Backpack"))
	scan(player.Character)

	local renderedAnyInTab = false

	for carName, data in pairs(inventoryData) do
		local tool = data.Tool
		local count = data.Count
		local stats = CarStats.Cars[carName]

		if stats and stats.Rarity == currentTab then
			renderedAnyInTab = true

			local btn = Instance.new("TextButton")
			btn.Name = stats.Rarity
			btn.Text = ""
			btn.Parent = itemsContainer
			btn.Size = UDim2.new(0, 100, 0, 120)
			btn.BackgroundColor3 = getRarityColor(stats.Rarity)
			btn.AutoButtonColor = false

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 8)
			corner.Parent = btn

			local icon = Instance.new("ImageLabel")
			icon.Name = "CarIcon"
			icon.Parent = btn
			icon.BackgroundTransparency = 1
			icon.Size = UDim2.new(1, 0, 1, 0)
			icon.Position = UDim2.new(0.5, 0, 0.5, 0)
			icon.AnchorPoint = Vector2.new(0.5, 0.5)
			icon.ScaleType = Enum.ScaleType.Fit
			icon.ZIndex = 1

			local imgCorner = Instance.new("UICorner")
			imgCorner.CornerRadius = UDim.new(0, 8)
			imgCorner.Parent = icon

			if stats.Image and stats.Image ~= "" then
				icon.Image = stats.Image
			elseif tool.TextureId and tool.TextureId ~= "" then
				icon.Image = tool.TextureId
			else
				icon.Image = CONFIG.Images.Default
			end

			local nameLabel = Instance.new("TextLabel")
			nameLabel.Name = "CarName"
			nameLabel.Parent = btn
			nameLabel.BackgroundTransparency = 1
			nameLabel.Size = UDim2.new(1, -4, 0.25, 0)
			nameLabel.Position = UDim2.new(0.5, 0, 0.85, 0)
			nameLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			nameLabel.Text = carName
			nameLabel.Font = Enum.Font.FredokaOne
			nameLabel.TextScaled = true
			nameLabel.ZIndex = 5

			ApplyUniversalGlow(nameLabel, stats.Rarity)

			if count >= 1 then
				local countTag = Instance.new("TextLabel")
				countTag.Name = "MultiplierCount"
				countTag.Parent = btn
				countTag.Text = "x" .. count
				countTag.Size = UDim2.new(0.35, 0, 0.25, 0)
				countTag.Position = UDim2.new(0.95, 0, 0.05, 0)
				countTag.AnchorPoint = Vector2.new(1, 0)
				countTag.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
				countTag.BackgroundTransparency = 0.4
				countTag.TextColor3 = CONFIG.Colors.Normal
				countTag.Font = Enum.Font.FredokaOne
				countTag.TextScaled = true
				countTag.ZIndex = 6

				local countCorner = Instance.new("UICorner")
				countCorner.CornerRadius = UDim.new(0, 6)
				countCorner.Parent = countTag
			end

			local isEquipped = false
			local charTool = player.Character:FindFirstChild(tool.Name)
			if charTool then isEquipped = true end

			if isEquipped then
				local stroke = Instance.new("UIStroke")
				stroke.Color = CONFIG.Colors.Gold
				stroke.Thickness = 4
				stroke.Parent = btn

				local equippedTag = nameLabel:Clone()
				equippedTag.Parent = btn
				equippedTag.Text = "EQUIPPED"
				equippedTag.TextColor3 = CONFIG.Colors.Gold
				equippedTag.Position = UDim2.new(0.5, 0, 0.5, 0)
				equippedTag.Rotation = -15
				equippedTag.ZIndex = 7

				for _, c in pairs(equippedTag:GetChildren()) do
					if c:IsA("UIGradient") then c:Destroy() end
				end
			end

			addButtonEffects(btn, false)

			btn.MouseButton1Click:Connect(function()
				playSfx(CONFIG.Audio.Equip, 0.5)
				local char = player.Character
				if not char then return end

				local existingTool = char:FindFirstChild(tool.Name)
				if existingTool then
					existingTool.Parent = player.Backpack
				else
					if tool.Parent == player.Backpack then
						for _, object in pairs(char:GetChildren()) do
							if object:IsA("Tool") then
								object.Parent = player.Backpack
							end
						end
						tool.Parent = char
					end
				end
				updateInventory()
			end)
		end
	end

	updateEmptyIndicator(currentTab, not renderedAnyInTab)
end

-- ============================================================================
-- üü¢ UI CONTROL LOGIC (FIXED CAMERA RETURN)
-- ============================================================================
local function performClose()
	mainWindow.Visible = false
	tierFrame.Visible = false
	openButton.Visible = true

	Controls:Enable()

	player.CameraMinZoomDistance = CONFIG.Zoom.Min
	player.CameraMaxZoomDistance = CONFIG.Zoom.Max

	toggleOtherGuis(false)

	TweenService:Create(camera, CONFIG.Tween, { FieldOfView = savedFOV }):Play()

	if shopMusic.IsPlaying then
		currentFadeTween = TweenService:Create(shopMusic, TweenInfo.new(1), { Volume = 0 })
		currentFadeTween:Play()
		currentFadeTween.Completed:Connect(function()
			shopMusic:Stop()
			if gameThemeSound then gameThemeSound:Resume() end
		end)
	end
end

closeButton.MouseButton1Click:Connect(function()
	playSfx(CONFIG.Audio.Click, 0.5)
	performClose()
end)

openButton.MouseButton1Click:Connect(function()
	playSfx(CONFIG.Audio.Click, 0.5)

	savedFOV = camera.FieldOfView

	if gameThemeSound and gameThemeSound.IsPlaying then gameThemeSound:Pause() end
	shopMusic.Volume = 0.5
	if not shopMusic.IsPlaying then shopMusic:Play() end

	toggleOtherGuis(true)
	currentTab = "Common"
	updateInventory()
	updateBackground()

	Controls:Disable()
	local currentZoom = (camera.CFrame.Position - camera.Focus.Position).Magnitude
	player.CameraMinZoomDistance = currentZoom
	player.CameraMaxZoomDistance = currentZoom

	mainWindow.Visible = true
	tierFrame.Visible = true
	openButton.Visible = false

	TweenService:Create(camera, CONFIG.Tween, { FieldOfView = CONFIG.FOV.Open }):Play()
end)

addOpenButtonHover(openButton)
addButtonEffects(closeButton, false)

if tierContainer then
	for _, btn in pairs(tierContainer:GetChildren()) do
		if btn:IsA("GuiButton") then
			addButtonEffects(btn, true)
			btn.MouseButton1Click:Connect(function()
				if btn.Name == "Mythic" then
					playSfx(CONFIG.Audio.Mythic, 1)
				else
					playSfx(CONFIG.Audio.Click, 0.5)
				end
				currentTab = btn.Name
				updateBackground()
				updateInventory()
			end)
		end
	end
end

-- ‚úÖ FINAL: PASTE THIS AT THE VERY BOTTOM (SCOPED: ONLY InventoryWindow > Indicator-v2)
-- ‚úÖ Removes label background edits + removes shadow label (no text covering)
do
	if not mainWindow then return end
	local indicator = mainWindow:FindFirstChild("Indicator-v2", true)
	if not indicator or not indicator:IsA("TextLabel") then return end

	-- Names for ONLY what we add (won't touch anything else)
	local TAG = "__InvEmptyFX"
	local STROKE_NAME = TAG .. "_Stroke"
	local TEXTGRAD_NAME = TAG .. "_TextGrad"
	local SCALE_NAME = TAG .. "_Scale"
	local SHINE_NAME = TAG .. "_Shine"
	local SHINEGRAD_NAME = TAG .. "_ShineGrad"

	local function getOrMake(className, parent, name)
		local obj = parent:FindFirstChild(name)
		if obj and obj.ClassName == className then return obj end
		if obj then obj:Destroy() end
		obj = Instance.new(className)
		obj.Name = name
		obj.Parent = parent
		return obj
	end

	-- Tier aesthetic palette (NO background colors touched)
	local function tierStyle(tier)
		local map = {
			Common = {
				textGrad = ColorSequence.new(Color3.fromRGB(245, 245, 245), Color3.fromRGB(165, 165, 165)),
				stroke = Color3.fromRGB(10, 10, 10),
				glow = Color3.fromRGB(255, 255, 255),
			},
			Uncommon = {
				textGrad = ColorSequence.new(Color3.fromRGB(170, 255, 195), Color3.fromRGB(10, 190, 75)),
				stroke = Color3.fromRGB(0, 60, 20),
				glow = Color3.fromRGB(160, 255, 200),
			},
			Rare = {
				textGrad = ColorSequence.new(Color3.fromRGB(175, 225, 255), Color3.fromRGB(40, 125, 255)),
				stroke = Color3.fromRGB(0, 35, 85),
				glow = Color3.fromRGB(170, 220, 255),
			},
			Epic = {
				textGrad = ColorSequence.new(Color3.fromRGB(235, 180, 255), Color3.fromRGB(160, 70, 255)),
				stroke = Color3.fromRGB(55, 0, 90),
				glow = Color3.fromRGB(235, 190, 255),
			},
			Legendary = {
				textGrad = ColorSequence.new(Color3.fromRGB(255, 240, 165), Color3.fromRGB(255, 175, 55)),
				stroke = Color3.fromRGB(90, 45, 0),
				glow = Color3.fromRGB(255, 235, 160),
			},
			Mythic = {
				textGrad = ColorSequence.new({
					ColorSequenceKeypoint.new(0.0, Color3.fromRGB(255, 90, 90)),
					ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 245, 140)),
					ColorSequenceKeypoint.new(1.0, Color3.fromRGB(255, 90, 255)),
				}),
				stroke = Color3.fromRGB(60, 0, 0),
				glow = Color3.fromRGB(255, 200, 255),
			},
		}
		return map[tier] or map.Common
	end

	local function tierFromText(txt)
		return (string.match(txt or "", "^Your%s+(%w+)%s+Stash%s+is%s+Empty")) or currentTab or "Common"
	end

	-- ‚úÖ remove old shadow if it exists (from previous versions)
	local oldShadow = indicator:FindFirstChild(TAG .. "_Shadow")
	if oldShadow and oldShadow:IsA("TextLabel") then
		oldShadow:Destroy()
	end

	-- Core FX objects (ONLY under indicator)
	local stroke = getOrMake("UIStroke", indicator, STROKE_NAME)
	stroke.LineJoinMode = Enum.LineJoinMode.Round
	stroke.Thickness = 3
	stroke.Transparency = 0.05

	local textGrad = getOrMake("UIGradient", indicator, TEXTGRAD_NAME)
	textGrad.Rotation = -20

	local scale = getOrMake("UIScale", indicator, SCALE_NAME)

	-- Glass shine overlay
	local shine = getOrMake("Frame", indicator, SHINE_NAME)
	shine.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	shine.BackgroundTransparency = 1
	shine.Size = UDim2.new(1, 0, 1, 0)
	shine.Position = UDim2.new(0, 0, 0, 0)
	shine.Visible = true

	-- copy corner if label has it (optional)
	local existingCorner = indicator:FindFirstChildOfClass("UICorner")
	if existingCorner and not shine:FindFirstChildOfClass("UICorner") then
		existingCorner:Clone().Parent = shine
	end

	local shineGrad = getOrMake("UIGradient", shine, SHINEGRAD_NAME)
	shineGrad.Rotation = -35
	shineGrad.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255), Color3.fromRGB(255, 255, 255))
	shineGrad.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0.00, 1.00),
		NumberSequenceKeypoint.new(0.35, 1.00),
		NumberSequenceKeypoint.new(0.48, 0.25),
		NumberSequenceKeypoint.new(0.52, 0.25),
		NumberSequenceKeypoint.new(0.65, 1.00),
		NumberSequenceKeypoint.new(1.00, 1.00),
	})

	-- ZIndex safety (ONLY affects indicator + shine, not TierFrame)
	local function enforceZ()
		indicator.ZIndex = math.max(indicator.ZIndex or 1, (mainWindow.ZIndex or 1) + 200)
		shine.ZIndex = indicator.ZIndex + 2
	end

	-- Animation control
	local pulseConn = nil
	local running = false

	local function stopAnim()
		running = false
		if pulseConn then pulseConn:Disconnect() pulseConn = nil end
		shine.BackgroundTransparency = 1
	end

	local function startAnim()
		if running then return end
		running = true

		-- pop-in (scale + fade) - text only, no shadow
		scale.Scale = 0.92
		indicator.TextTransparency = 0.35
		TweenService:Create(scale, TweenInfo.new(0.22, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1 }):Play()
		TweenService:Create(indicator, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { TextTransparency = 0 }):Play()

		-- subtle breathing + moving shine sweep
		local t0 = tick()
		pulseConn = RunService.Heartbeat:Connect(function()
			if not indicator.Visible then return end
			enforceZ()

			local t = tick() - t0

			-- shimmer in text gradient
			local shimmer = 0.12 + 0.10 * math.sin(t * 2.2)
			textGrad.Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, shimmer),
				NumberSequenceKeypoint.new(1, shimmer + 0.04),
			})

			-- glass shine sweep across the label
			shine.BackgroundTransparency = 0.88
			local sweep = (t * 0.55) % 1
			shineGrad.Offset = Vector2.new(-1.2 + sweep * 2.4, 0)

			-- tiny glow pulse via stroke thickness
			stroke.Thickness = 2.6 + 0.9 * (0.5 + 0.5 * math.sin(t * 2.2))
		end)
	end

	local function applyTierLook()
		local tier = tierFromText(indicator.Text)
		local st = tierStyle(tier)

		-- IMPORTANT: do NOT touch BackgroundTransparency/BackgroundColor3 (your request)
		stroke.Color = Color3.fromRGB(
			math.floor((st.stroke.R * 255 + st.glow.R * 255 * 0.25) / 1.25),
			math.floor((st.stroke.G * 255 + st.glow.G * 255 * 0.25) / 1.25),
			math.floor((st.stroke.B * 255 + st.glow.B * 255 * 0.25) / 1.25)
		)
		textGrad.Color = st.textGrad
	end

	local function refresh()
		enforceZ()
		indicator.Active = false -- your rule
		applyTierLook()

		if indicator.Visible then
			startAnim()
		else
			stopAnim()
		end
	end

	-- React ONLY to this label
	indicator:GetPropertyChangedSignal("Visible"):Connect(refresh)
	indicator:GetPropertyChangedSignal("Text"):Connect(refresh)
	indicator:GetPropertyChangedSignal("ZIndex"):Connect(enforceZ)

	-- Update tier colors even if text doesn't change (tier switching)
	task.spawn(function()
		local last = nil
		while indicator.Parent do
			if currentTab ~= last then
				last = currentTab
				applyTierLook()
			end
			task.wait(0.05)
		end
	end)

	-- initial
	refresh()
end
