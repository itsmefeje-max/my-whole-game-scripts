-- [[ SERVER SIDE: TycoonDataHandler (Refactored V29: PERSISTENCE FIXED) ]]
-- [[ FIXES: Race Condition, Data Integrity, Safe Serialization ]]

local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local DataStoreService = game:GetService("DataStoreService")
local Workspace = game:GetService("Workspace")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- üíæ DATA CONFIGURATION
local DATA_KEY = "TycoonData_Release_V25_Fixed"
local PlayerDataStore = DataStoreService:GetDataStore(DATA_KEY)

-- üìÇ ASSET REFERENCES
local CarTools = ServerStorage:WaitForChild("CarTools")
local CarModels = ServerStorage:WaitForChild("CarModels")
local TycoonFolder = Workspace:WaitForChild("Tycoons")

-- üìö MODULES
local CarStats = require(ReplicatedStorage:WaitForChild("CarStats"))

-- ‚öôÔ∏è CONSTANTS
local STARTER_CAR_NAME = "Delta Item" 
local AUTOSAVE_INTERVAL = 120 -- Seconds (Optional safety)

-- ============================================================================
-- üîç HELPER FUNCTIONS (PRESERVED)
-- ============================================================================

local function debugLog(player, message)
	print("üîç [DATA][" .. player.Name .. "]: " .. message)
end

local function notify(player, msg)
	pcall(function()
		local channel = TextChatService.TextChannels.RBXGeneral
		if channel then 
			channel:DisplaySystemMessage("<font color='#FFAA00'>[SYSTEM]: " .. msg .. "</font>") 
		end
	end)
end

-- Reverse lookup: Finds the Inventory Tool Name based on the Placed Model Name
local function FindToolNameFromModel(modelName)
	if CarTools:FindFirstChild(modelName) then return modelName end
	if CarTools:FindFirstChild(modelName .. " Item") then return modelName .. " Item" end

	-- String cleanup approach
	local clean = modelName:gsub(" Item", ""):gsub("Item", "")
	for _, t in pairs(CarTools:GetChildren()) do
		if t.Name:gsub(" Item", "") == clean then return t.Name end
	end

	-- Smart CarStats lookup (The most robust method)
	if CarStats and CarStats.Cars then
		for internalID, stats in pairs(CarStats.Cars) do
			if stats.Name == modelName then
				if CarTools:FindFirstChild(internalID .. " Item") then return internalID .. " Item"
				elseif CarTools:FindFirstChild(internalID) then return internalID end
			end
		end
	end
	return nil
end

-- Forward lookup: Finds the Model Name based on the Inventory Tool Name
local function FindModelNameFromTool(toolName)
	local clean = toolName:gsub(" Item", ""):gsub("Item", "")
	if CarModels:FindFirstChild(clean) then return clean end

	-- Check CarStats for display name mapping
	if CarStats and CarStats.Cars and CarStats.Cars[clean] then
		local stats = CarStats.Cars[clean]
		if CarModels:FindFirstChild(stats.Name) then return stats.Name end
	end
	return nil
end

-- Utility to find the physical part of a pad/model
local function getMainPart(obj)
	if obj:IsA("BasePart") then return obj end
	if obj:IsA("Model") then
		if obj.PrimaryPart then return obj.PrimaryPart end
		for _, child in pairs(obj:GetChildren()) do
			if child:IsA("BasePart") and child.Name ~= "Border" then return child end
		end
		return obj:FindFirstChildWhichIsA("BasePart")
	end
	return nil
end

-- Safely gives items ensuring no duplicates in current session
local function giveTool(player, toolName)
	if not player or not player.Parent then return end

	-- Check Backpack and StarterGear
	if player.Backpack:FindFirstChild(toolName) then return end
	if player:FindFirstChild("StarterGear") and player.StarterGear:FindFirstChild(toolName) then return end

	-- Attempt to find the tool
	local tool = CarTools:FindFirstChild(toolName)
	if not tool then tool = CarTools:FindFirstChild(toolName:gsub(" Item", "")) end

	-- Fallback to reverse lookup if name doesn't match perfectly
	if not tool then
		local rec = FindToolNameFromModel(toolName)
		if rec then tool = CarTools:FindFirstChild(rec) end
	end

	if tool then
		-- Grant item
		tool:Clone().Parent = player.Backpack
		tool:Clone().Parent = player.StarterGear
		debugLog(player, "üéÅ Given Item: " .. toolName)
	else
		warn("‚ö†Ô∏è Could not find tool to give: " .. tostring(toolName))
	end
end

-- ============================================================================
-- üèóÔ∏è RESTORE LAYOUT (LOGIC FIXED)
-- ============================================================================
local function RestoreLayout(player, plot, layoutData)
	if not layoutData then return end
	debugLog(player, "üèóÔ∏è Restoring " .. #layoutData .. " cars...")

	local padsFolder = plot:WaitForChild("Pads", 10)
	if not padsFolder then warn("‚ùå Pads folder missing in " .. plot.Name) return end

	local placedCarsFolder = plot:FindFirstChild("PlacedCars")
	if not placedCarsFolder then
		placedCarsFolder = Instance.new("Folder")
		placedCarsFolder.Name = "PlacedCars"
		placedCarsFolder.Parent = plot
	end

	for i, data in pairs(layoutData) do
		local toolName = data.Tool
		local padName = data.Pad

		local padObject = padsFolder:FindFirstChild(padName)
		if padObject then
			local padPart = getMainPart(padObject)
			if padPart then
				local isOccupied = padPart:FindFirstChild("IsOccupied")

				-- Only restore if the pad is actually empty (prevents dupes)
				if isOccupied and not isOccupied.Value then
					local realModelName = FindModelNameFromTool(toolName)

					if realModelName then
						local carModel = CarModels:FindFirstChild(realModelName)
						if carModel then
							local newCar = carModel:Clone()

							-- üõ°Ô∏è PHYSICS FIX: Anchor BEFORE parenting
							-- This prevents the car from flying off due to physics collisions on spawn
							for _, p in pairs(newCar:GetDescendants()) do
								if p:IsA("BasePart") then 
									p.Anchored = true 
									p.CanCollide = true 
								end
							end

							-- üõ°Ô∏è POSITIONING: Place perfectly on top
							-- We assume PadController logic: Pad Center + Vertical Offset
							local padTop = padPart.CFrame * CFrame.new(0, (padPart.Size.Y/2) + 5, 0)
							newCar:PivotTo(padTop)

							-- üõ°Ô∏è PARENTING: Safe to parent now
							newCar.Parent = placedCarsFolder 

							-- üõ°Ô∏è STATE SYNC: Lock the pad so PadController knows it's full
							isOccupied.Value = true
							local linked = padPart:FindFirstChild("LinkedCar")
							if not linked then 
								linked = Instance.new("ObjectValue", padPart)
								linked.Name = "LinkedCar" 
							end
							linked.Value = newCar

							-- üõ°Ô∏è PROMPTS: Update interaction prompts
							if padPart:FindFirstChild("PlacePrompt") then padPart.PlacePrompt.Enabled = false end
							if padPart:FindFirstChild("PickupPrompt") then padPart.PickupPrompt.Enabled = true end

							print("   ‚úÖ [RESTORE] Safely placed " .. realModelName .. " on " .. padName)
						else
							warn("   ‚ùå [RESTORE] Model missing in ServerStorage: " .. realModelName)
						end
					else
						warn("   ‚ùå [RESTORE] Could not map Tool '"..tostring(toolName).."' to a Model.")
					end
				end
			end
		end
	end
end

-- ============================================================================
-- üíæ SAVING (DATA INTEGRITY PROTECTED)
-- ============================================================================
local function save(player)
	print("üíæ [SAVE START] for " .. player.Name)

	-- üõ°Ô∏è DATA LOSS PREVENTION
	-- If data failed to load, DO NOT OVERWRITE with empty data.
	if not player:GetAttribute("DataLoaded") then 
		warn("‚ö†Ô∏è [SAVE ABORTED] Data was not loaded for " .. player.Name)
		return 
	end

	local inventory = {}
	local layout = {}
	local seen = {}
	local totalPending = player:GetAttribute("RestoredPending") or 0

	-- 1. CAPTURE INVENTORY (Deduplicated)
	local function add(name)
		if not seen[name] then 
			table.insert(inventory, name)
			seen[name] = true 
		end
	end

	-- Scan Backpack
	for _, t in pairs(player.Backpack:GetChildren()) do 
		if CarTools:FindFirstChild(t.Name) then add(t.Name) end 
	end
	-- Scan StarterGear (Items persist after death)
	if player:FindFirstChild("StarterGear") then
		for _, t in pairs(player.StarterGear:GetChildren()) do 
			if CarTools:FindFirstChild(t.Name) then add(t.Name) end 
		end
	end

	-- 2. CAPTURE LAYOUT (Placed Cars)
	local plotName = player:GetAttribute("OccupiedPlot")
	if plotName and TycoonFolder:FindFirstChild(plotName) then
		local plot = TycoonFolder[plotName]

		-- Save uncollected cash
		if plot:FindFirstChild("PendingEarnings") then 
			totalPending = totalPending + plot.PendingEarnings.Value 
		end

		local pads = plot:FindFirstChild("Pads")
		if pads then
			for _, padObject in pairs(pads:GetChildren()) do
				local padPart = getMainPart(padObject)
				if padPart then
					local linked = padPart:FindFirstChild("LinkedCar")
					-- Check if a car is linked and actually exists
					if linked and linked.Value and linked.Value.Parent then
						local carName = linked.Value.Name
						local tName = FindToolNameFromModel(carName)

						if tName then
							-- Save position
							table.insert(layout, {Tool = tName, Pad = padObject.Name})

							-- Ensure player "owns" the placed item too
							add(tName) 
							print("   ‚úÖ SAVED: " .. carName .. " (as " .. tName .. ")")
						end
					end
				end
			end
		end
	end

	-- 3. COMMIT TO DATASTORE
	local key = "User_V25_" .. player.UserId
	local success, err = pcall(function()
		PlayerDataStore:UpdateAsync(key, function(oldData)
			return {
				Bank = player.leaderstats.Cash.Value,
				Wallet = player.leaderstats.Wallet.Value,
				ATMBalance = player.leaderstats.ATMBalance.Value,
				Inventory = inventory,
				Layout = layout,
				PendingEarnings = totalPending
			}
		end)
	end)

	if success then
		notify(player, "üíæ Data Saved.")
	else
		warn("‚ùå [SAVE ERROR] " .. tostring(err))
	end
end

-- ============================================================================
-- üì• LOADING (RACE CONDITION FIXED)
-- ============================================================================
Players.PlayerAdded:Connect(function(player)
	-- 1. Initialize Leaderstats
	local ls = Instance.new("Folder")
	ls.Name = "leaderstats"; ls.Parent = player
	local cash = Instance.new("IntValue"); cash.Name = "Cash"; cash.Parent = ls
	local wallet = Instance.new("IntValue"); wallet.Name = "Wallet"; wallet.Parent = ls
	local atm = Instance.new("IntValue"); atm.Name = "ATMBalance"; atm.Parent = ls

	-- Chat command for manual save
	player.Chatted:Connect(function(msg) if msg:lower() == "/save" then save(player) end end)

	-- 2. Fetch Data
	local key = "User_V25_" .. player.UserId
	local data = nil
	local success, err = pcall(function() data = PlayerDataStore:GetAsync(key) end)

	if success then
		-- üõ°Ô∏è MARK DATA AS LOADED (Enables Saving)
		player:SetAttribute("DataLoaded", true)

		if data then
			-- Restore Values
			cash.Value = data.Bank or 0
			wallet.Value = data.Wallet or 0
			atm.Value = data.ATMBalance or 0

			-- Restore Inventory
			if data.Inventory then
				for _, name in pairs(data.Inventory) do giveTool(player, name) end
			end

			-- [[ üö® CRITICAL FIX: PLACEMENT RESTORATION ]]
			if data.Layout and #data.Layout > 0 then

				-- Define the Restoration Function locally
				local hasRestored = false -- Debounce to prevent double restoration
				local function TriggerRestore()
					if hasRestored then return end

					local plotName = player:GetAttribute("OccupiedPlot")
					if plotName then
						local plot = TycoonFolder:FindFirstChild(plotName)
						if plot then
							hasRestored = true
							print("üèóÔ∏è Plot Detected ("..plotName.."). Triggering RestoreLayout...")

							-- Small delay to ensure plot visuals are fully streamed/loaded
							task.wait(1) 
							RestoreLayout(player, plot, data.Layout)
						end
					end
				end

				-- PATH A: Event Listener (If plot is assigned LATER)
				player:GetAttributeChangedSignal("OccupiedPlot"):Connect(TriggerRestore)

				-- PATH B: Immediate Check (If plot was assigned DURING loading)
				-- This specifically fixes the race condition where GetAsync() yields too long
				if player:GetAttribute("OccupiedPlot") then
					task.spawn(TriggerRestore)
				end
			end
			-- [[ END OF FIX ]]

			-- Starter Item Fallback
			if (#data.Inventory == 0) and (not data.Layout or #data.Layout == 0) then
				giveTool(player, STARTER_CAR_NAME)
			end

			if data.PendingEarnings then player:SetAttribute("RestoredPending", data.PendingEarnings) end
		else
			-- New Player
			giveTool(player, STARTER_CAR_NAME)
		end
	else
		-- Kick to prevent data overwriting
		player:Kick("Data Load Error. Please Rejoin.")
	end

	-- Restore Pending Earnings Logic
	player:GetAttributeChangedSignal("OccupiedPlot"):Connect(function() 
		local amount = player:GetAttribute("RestoredPending")
		if amount and amount > 0 then
			local plotName = player:GetAttribute("OccupiedPlot")
			local plot = TycoonFolder:FindFirstChild(plotName)
			-- Wait for PendingEarnings value to exist
			local pendingVal = plot and plot:WaitForChild("PendingEarnings", 10)

			if pendingVal then
				pendingVal.Value = pendingVal.Value + amount
				player:SetAttribute("RestoredPending", 0) -- Clear buffer
			end
		end
	end)
end)

-- ============================================================================
-- üõë SHUTDOWN HANDLING
-- ============================================================================
Players.PlayerRemoving:Connect(save)

game:BindToClose(function()
	if RunService:IsStudio() then
		-- Fast save for studio
		for _, p in pairs(Players:GetPlayers()) do save(p) end
		task.wait(2)
	else
		-- Robust save for live servers
		local threads = 0
		for _, p in pairs(Players:GetPlayers()) do
			threads = threads + 1
			task.spawn(function()
				save(p)
				threads = threads - 1
			end)
		end
		-- Wait until all threads finish or 30s timeout
		local start = os.clock()
		while threads > 0 and (os.clock() - start) < 30 do
			task.wait()
		end
	end
end)
