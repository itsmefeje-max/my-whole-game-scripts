-- [[ SERVER SCRIPT: LocalShopService (Best Version) ]]
-- Currency: leaderstats.Wallet
-- Global rotation: deterministic per RESTOCK_INTERVAL
-- Local reroll: per-player seed
-- Security: UserId mutex locks, success-only cooldown, pcall wrapper
-- Reliability: no update spam, correct IsGlobal, dedupe that survives rejoin

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

-- =========================
-- CONFIG
-- =========================
local CAR_WEIGHTS = {Delta = 50, Iva = 20, Atom = 15, Windsor = 9, Senator = 5, Riva = 1}
local ALWAYS_STOCK = {Delta = true, Iva = true}

local RESTOCK_INTERVAL = 300
local PURCHASE_COOLDOWN = 0.5

-- =========================
-- MODULES (require once)
-- =========================
local CarStats = require(ReplicatedStorage:WaitForChild("CarStats"))

-- =========================
-- REMOTES
-- =========================
local Remotes = ReplicatedStorage:FindFirstChild("ShopRemotes")
if not Remotes then
	Remotes = Instance.new("Folder")
	Remotes.Name = "ShopRemotes"
	Remotes.Parent = ReplicatedStorage
end

local function getRemote(name, className)
	local r = Remotes:FindFirstChild(name)
	if not r then
		r = Instance.new(className)
		r.Name = name
		r.Parent = Remotes
	end
	return r
end

local RemoteOpen = getRemote("OpenLocalShop", "RemoteEvent")         -- client -> server (optional)
local RemoteUpdate = getRemote("ShopUpdate", "RemoteEvent")          -- server -> client
local FuncGetState = getRemote("GetShopState", "RemoteFunction")     -- client -> server
local FuncBuyCar = getRemote("BuyLocalCar", "RemoteFunction")        -- client -> server

-- =========================
-- BINDABLE (server -> server)
-- =========================
local RerollBindable = ServerStorage:FindFirstChild("ShopRerollFunction")
if not RerollBindable then
	RerollBindable = Instance.new("BindableFunction")
	RerollBindable.Name = "ShopRerollFunction"
	RerollBindable.Parent = ServerStorage
end

-- =========================
-- STATE
-- =========================
local PlayerSessions = {}       -- [userId] = { SeedVersion, LocalSeed, Purchased, Cache }
local PurchaseLocks = {}        -- [userId] = true/nil
local LastPurchaseTime = {}     -- [userId] = os.clock()

-- =========================
-- TOOL TAGGING + PERSISTENT ID
-- =========================

-- Persistent marker name (survives in StarterGear better than Attributes)
local PERSIST_ID_NAME = "__ShopToolId"

local function setPersistentToolId(tool, toolId)
	-- Attributes are great for runtime checks, but not reliable for persistence in StarterGear across sessions.
	tool:SetAttribute("ToolId", toolId)

	local marker = tool:FindFirstChild(PERSIST_ID_NAME)
	if not marker then
		marker = Instance.new("StringValue")
		marker.Name = PERSIST_ID_NAME
		marker.Parent = tool
	end
	marker.Value = toolId
end

local function getPersistentToolId(tool)
	local marker = tool:FindFirstChild(PERSIST_ID_NAME)
	if marker and marker:IsA("StringValue") then
		return marker.Value
	end
	-- fallback to attribute (runtime)
	return tool:GetAttribute("ToolId")
end

local function tagIssued(tool, toolId)
	if not tool then return end
	tool:SetAttribute("IssuedByServer", true)
	tool:SetAttribute("IssuedAt", os.time())
	tool:SetAttribute("IssuedId", HttpService:GenerateGUID(false))
	tool.CanBeDropped = false

	-- stable ID used for saving + dedupe
	setPersistentToolId(tool, toolId)
end

local function starterGearHasToolId(player, toolId)
	local sg = player:FindFirstChild("StarterGear")
	if not sg then return false end

	for _, child in ipairs(sg:GetChildren()) do
		-- check marker (best), then attribute
		if getPersistentToolId(child) == toolId then
			return true
		end
	end
	return false
end

-- =========================
-- SHOP LOGIC
-- =========================
local function getGlobalSeedID()
	return math.floor(os.time() / RESTOCK_INTERVAL)
end

local function calculateStockForCar(carName, rng)
	local weight = CAR_WEIGHTS[carName] or 0
	local limit = 1

	-- Roll 1: chance to get +1
	if rng:NextInteger(1, 100) <= weight then
		limit += 1
		-- Roll 2: small chance to get +1 again (cap 3)
		if limit == 2 and rng:NextInteger(1, 100) <= math.ceil(weight * 0.5) then
			limit += 1
		end
	end

	return limit
end

local function generateStockConfiguration(seedValue)
	local rng = Random.new(seedValue)

	local featuredFlags = {}
	local stockLimits = {}

	-- Always stock
	for name in pairs(ALWAYS_STOCK) do
		featuredFlags[name] = true
		stockLimits[name] = calculateStockForCar(name, rng)
	end

	-- Weighted pool (everything not always-stock)
	local poolKeys = {}
	local poolWeights = {}
	local totalWeight = 0

	for name, weight in pairs(CAR_WEIGHTS) do
		if not ALWAYS_STOCK[name] then
			table.insert(poolKeys, name)
			poolWeights[name] = weight
			totalWeight += weight
		end
	end

	-- If config gets messed up, avoid crashing
	if totalWeight <= 0 or #poolKeys == 0 then
		return { Featured = featuredFlags, Limits = stockLimits }
	end

	-- Rotation count
	local r = rng:NextInteger(1, 100)
	local targetCount = (r > 90 and 3) or (r > 55 and 2) or 1

	local pickedCount = 0
	local safety = 0

	while pickedCount < targetCount and safety < 50 do
		safety += 1
		local roll = rng:NextInteger(1, totalWeight)

		local current = 0
		local picked = nil
		for _, car in ipairs(poolKeys) do
			current += poolWeights[car]
			if roll <= current then
				picked = car
				break
			end
		end

		if picked and not featuredFlags[picked] then
			featuredFlags[picked] = true
			stockLimits[picked] = calculateStockForCar(picked, rng)
			pickedCount += 1
		end
	end

	return { Featured = featuredFlags, Limits = stockLimits }
end

local function calculateCurrentStock(limits, purchasedCounts)
	local current = {}
	for car, limit in pairs(limits) do
		local bought = purchasedCounts[car] or 0
		local left = limit - bought
		if left < 0 then left = 0 end
		current[car] = left
	end
	return current
end

-- Creates/updates session; returns session + didReset
local function getSession(player)
	local uid = player.UserId
	local currentGlobalID = getGlobalSeedID()

	if not PlayerSessions[uid] then
		PlayerSessions[uid] = {
			SeedVersion = currentGlobalID,
			LocalSeed = nil,
			Purchased = {},
			Cache = nil,
		}
	end

	local session = PlayerSessions[uid]
	local didReset = false

	-- rotation changed => force back to global
	if session.SeedVersion ~= currentGlobalID then
		session.SeedVersion = currentGlobalID
		session.LocalSeed = nil
		session.Purchased = {}
		session.Cache = generateStockConfiguration(session.SeedVersion)
		didReset = true
	end

	-- lazy cache init
	if not session.Cache then
		local seed = session.LocalSeed or session.SeedVersion
		session.Cache = generateStockConfiguration(seed)
	end

	return session, didReset
end

local function buildStatePayload(session)
	local config = session.Cache
	local currentStock = calculateCurrentStock(config.Limits, session.Purchased)

	return {
		Featured = config.Featured,
		StockLimit = config.Limits,
		Stock = currentStock,
		Purchased = session.Purchased,
		NextRestock = (getGlobalSeedID() + 1) * RESTOCK_INTERVAL,
		IsGlobal = (session.LocalSeed == nil),
	}
end

local function pushUpdate(player, session, reason)
	local payload = buildStatePayload(session)
	payload.Reason = reason
	RemoteUpdate:FireClient(player, payload)
end

-- =========================
-- GET STATE
-- =========================
FuncGetState.OnServerInvoke = function(player)
	local session, didReset = getSession(player)

	-- If they happened to call exactly as rotation changed, client will learn via returned state anyway.
	-- We avoid RemoteUpdate spam here; rotation loop handles "Auto" pushes.
	return buildStatePayload(session)
end

-- Optional: client can fire OpenLocalShop to get a one-time push update
RemoteOpen.OnServerEvent:Connect(function(player)
	local session = getSession(player)
	pushUpdate(player, session, "Open")
end)

-- =========================
-- BUY
-- =========================
FuncBuyCar.OnServerInvoke = function(player, carName)
	if typeof(carName) ~= "string" then
		return false, "Invalid Car"
	end
	if not player or not player.Parent then
		return false, "Player not available"
	end

	local uid = player.UserId

	-- Mutex
	if PurchaseLocks[uid] then
		return false, "Purchase in progress"
	end

	-- Cooldown (checked before lock is set)
	if (os.clock() - (LastPurchaseTime[uid] or 0)) < PURCHASE_COOLDOWN then
		return false, "Slow down"
	end

	PurchaseLocks[uid] = true

	local pOk, logicOk, msg = pcall(function()
		local session, didReset = getSession(player)

		-- If rotation reset happened during this call, optionally push Auto once here:
		-- (Usually rotation loop will do it, but this makes purchases safe even if loop is laggy.)
		if didReset then
			pushUpdate(player, session, "Auto")
		end

		local config = session.Cache
		local carsTable = CarStats and CarStats.Cars
		if typeof(carsTable) ~= "table" then
			return false, "CarStats Error"
		end

		local carData = carsTable[carName]
		if not carData or not config.Featured[carName] then
			return false, "Invalid Car"
		end

		if typeof(carData.Price) ~= "number" then
			return false, "Price Config Error"
		end

		local bought = session.Purchased[carName] or 0
		local limit = config.Limits[carName] or 0
		if bought >= limit then
			return false, "Out of Stock"
		end

		-- Wallet
		local ls = player:FindFirstChild("leaderstats")
		local wallet = ls and ls:FindFirstChild("Wallet")
		if not wallet or not wallet:IsA("IntValue") then
			return false, "Wallet Not Found"
		end

		if wallet.Value < carData.Price then
			return false, "Insufficient Cash (Withdraw from ATM)"
		end

		-- Tool source
		local toolsFolder = ServerStorage:FindFirstChild("CarTools")
		if not toolsFolder then
			return false, "System Error: Tool Folder Missing"
		end

		local toolSource = toolsFolder:FindFirstChild(carName) or toolsFolder:FindFirstChild(carName .. " Item")
		if not toolSource then
			return false, "System Error: Tool Missing"
		end

		-- Charge first (still safe; we refund on any later failure inside pcall)
		wallet.Value -= carData.Price

		-- Give Backpack tool
		local backpack = player:FindFirstChildOfClass("Backpack")
		if not backpack then
			-- Refund if backpack missing
			wallet.Value += carData.Price
			return false, "System Error: Backpack Missing"
		end

		local backpackTool = toolSource:Clone()
		tagIssued(backpackTool, carName) -- stable id = carName
		backpackTool.Parent = backpack

		-- Give StarterGear tool if not already owned (dedupe survives rejoin)
		local sg = player:FindFirstChild("StarterGear")
		if sg and not starterGearHasToolId(player, carName) then
			local gearTool = toolSource:Clone()
			tagIssued(gearTool, carName)
			gearTool.Parent = sg
		end

		-- Increment purchase count
		session.Purchased[carName] = bought + 1

		-- Push update to client
		pushUpdate(player, session, "Purchase")

		return true, "Success"
	end)

	-- release lock
	PurchaseLocks[uid] = nil

	if not pOk then
		warn("Shop System Error:", logicOk) -- logicOk is the error string
		return false, "Internal System Error"
	end

	-- cooldown only on actual success
	if logicOk then
		LastPurchaseTime[uid] = os.clock()
	end

	return logicOk, msg
end

-- =========================
-- REROLL (server-side callable)
-- =========================
function RerollBindable.OnInvoke(player)
	if not player or not player.Parent then
		return false
	end

	local session = getSession(player)

	session.LocalSeed = math.random(1, 999999999)
	session.Purchased = {}
	session.Cache = generateStockConfiguration(session.LocalSeed)

	pushUpdate(player, session, "Reroll")
	return true
end

-- =========================
-- ROTATION LOOP
-- =========================
task.spawn(function()
	local lastGlobalID = getGlobalSeedID()

	while true do
		task.wait(1)
		local currentID = getGlobalSeedID()

		if currentID ~= lastGlobalID then
			lastGlobalID = currentID
			print("ðŸ”„ GLOBAL SHOP ROTATION")

			for _, player in ipairs(Players:GetPlayers()) do
				local session, didReset = getSession(player)
				if didReset then
					pushUpdate(player, session, "Auto")
				end
			end
		end
	end
end)

-- =========================
-- CLEANUP
-- =========================
Players.PlayerRemoving:Connect(function(player)
	local uid = player.UserId
	PlayerSessions[uid] = nil
	PurchaseLocks[uid] = nil
	LastPurchaseTime[uid] = nil
end)
