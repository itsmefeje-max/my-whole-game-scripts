-- Purpose: Centralizes MarketplaceService.ProcessReceipt with IDEMPOTENCY & GIFTING.
-- Runs on: Server
-- Location: ServerScriptService
-- Dependencies: MarketplaceService, DataStoreService, ServerStorage, ReplicatedStorage, GiftIntentHandler
-- Public API: MarketplaceService.ProcessReceipt (Callback)
-- Networking: N/A
-- Security: Strict datastore error handling prevents duplicate rewards; safe container checks prevent infinite yields.
-- Performance: Replaces WaitForChild with FindFirstChild to prevent memory leaks on player disconnect.
-- Notes: Assumes GiftIntentHandler (_G.GetGiftReceiver) handles invalid/offline user IDs gracefully.

local MarketplaceService = game:GetService("MarketplaceService")
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

-- üíæ DATASTORE FOR RECEIPT HISTORY
local PurchaseHistory = DataStoreService:GetDataStore("PurchaseHistory")

-- ‚öôÔ∏è EXISTING PRODUCT IDs
local TABLET_2X_ID = 3509697462 -- Tablet ID
local SHOP_REROLL_ID = 3520990584 -- Reroll ID

-- üöó CAR PRODUCT IDs
local CAR_PRODUCT_IDS = {
	[3524326648] = "Delta",
	[3524327150] = "Iva",
	[3524327478] = "Atom",
	[3524327780] = "Windsor",
	[3524328208] = "Senator",
	[3524328713] = "Riva"
}

-- üîó REFERENCES
local TycoonFolder = Workspace:WaitForChild("Tycoons")
local ShopRerollFunc = ServerStorage:WaitForChild("ShopRerollFunction")

-- ‚úÖ Base Skin Module Reference
local BaseSkinStats
pcall(function()
	BaseSkinStats = require(ReplicatedStorage:WaitForChild("BaseSkinStats"))
end)

-- ============================================================================
-- üßæ MAIN RECEIPT PROCESSOR
-- ============================================================================
MarketplaceService.ProcessReceipt = function(receiptInfo)
	local buyerId = receiptInfo.PlayerId
	local buyerPlayer = Players:GetPlayerByUserId(buyerId)

	-- 1. Handle Buyer Leaving/Crashing
	-- Even if gifting, we need the buyer's record to process the ID
	if not buyerPlayer then return Enum.ProductPurchaseDecision.NotProcessedYet end

	-- üéÅ GIFTING LOGIC: Determine the Recipient
	local targetPlayer = buyerPlayer -- Default to buyer
	local isGift = false

	-- Check if the GiftIntentHandler (Global) has a pending gift note for this buyer
	if _G.GetGiftReceiver then
		local receiverId = _G.GetGiftReceiver(buyerId)
		if receiverId then
			local receiver = Players:GetPlayerByUserId(receiverId)
			if receiver then
				targetPlayer = receiver
				isGift = true
				print("üéÅ GIFT DETECTED! From " .. buyerPlayer.Name .. " to " .. targetPlayer.Name)
			else
				warn("‚ö†Ô∏è Gift Receiver (ID: " .. tostring(receiverId) .. ") is offline. Defaulting item to Buyer.")
			end
		end
	end

	-- üõ°Ô∏è SECURITY: IDEMPOTENCY CHECK (Prevents Double Rewards)
	-- We use the BUYER'S ID for the key because they are the one paying.
	local purchaseKey = buyerId .. "_" .. receiptInfo.PurchaseId
	local success, alreadyProcessed = pcall(function()
		return PurchaseHistory:GetAsync(purchaseKey)
	end)

	-- If DataStore fails, we DON'T grant (try again later)
	if not success then 
		warn("‚ö†Ô∏è DataStore Error during receipt check. Retrying...")
		return Enum.ProductPurchaseDecision.NotProcessedYet 
	end

	-- If we already processed this ID, tell Roblox "We're done" and stop.
	if alreadyProcessed then
		print("‚ôªÔ∏è Duplicate Purchase ID detected. Skipping reward.")
		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	-- Proceed with Purchase Logic (Applying to targetPlayer)
	local pid = receiptInfo.ProductId
	local purchaseSuccess = false 

	print("üõí Processing Purchase for ProductID: " .. pid .. " | Receiver: " .. targetPlayer.Name)

	-- ====================================================
	-- 1Ô∏è‚É£ PRODUCT: TABLET 2X EARNINGS
	-- ====================================================
	if pid == TABLET_2X_ID then
		-- Apply to TARGET PLAYER'S Plot
		local myPlotName = targetPlayer:GetAttribute("OccupiedPlot")
		local plot = myPlotName and TycoonFolder:FindFirstChild(myPlotName)

		if plot and plot:FindFirstChild("PendingEarnings") then 
			local pendingVal = plot.PendingEarnings
			local amount = pendingVal.Value

			if amount > 0 then
				pendingVal.Value = 0
				local ls = targetPlayer:FindFirstChild("leaderstats")
				if ls and ls:FindFirstChild("Cash") then
					ls.Cash.Value += (amount * 2)
				end
			end
			purchaseSuccess = true
		end

		-- ====================================================
		-- 2Ô∏è‚É£ PRODUCT: SHOP REROLL (Restock)
		-- ====================================================
	elseif pid == SHOP_REROLL_ID then
		if ShopRerollFunc then
			-- Invoke for TARGET PLAYER
			ShopRerollFunc:Invoke(targetPlayer) 
			purchaseSuccess = true
		else
			warn("‚ö†Ô∏è Critical: ShopRerollFunction missing!")
		end

		-- ====================================================
		-- 3Ô∏è‚É£ PRODUCT: BASE SKINS (Silver/Gold/Diamond/Rainbow)
		-- ====================================================
	elseif BaseSkinStats then
		local skinFound = nil
		for name, data in pairs(BaseSkinStats) do
			if data.ProductId == pid then
				skinFound = name
				break
			end
		end

		if skinFound then
			-- Grant Ownership to TARGET PLAYER
			local ownedRaw = targetPlayer:GetAttribute("OwnedBaseSkins") or "[]"
			local ownedTable = {}
			local decodeSuccess, _ = pcall(function() ownedTable = HttpService:JSONDecode(ownedRaw) end)
			if not decodeSuccess then ownedTable = {} end

			if not table.find(ownedTable, skinFound) then
				table.insert(ownedTable, skinFound)
				targetPlayer:SetAttribute("OwnedBaseSkins", HttpService:JSONEncode(ownedTable))
			end

			targetPlayer:SetAttribute("EquippedSkin", skinFound)
			purchaseSuccess = true
		end

		-- ====================================================
		-- 4Ô∏è‚É£ PRODUCT: BUY CAR WITH ROBUX
		-- ====================================================
	elseif CAR_PRODUCT_IDS[pid] then
		local carName = CAR_PRODUCT_IDS[pid]
		local CarTools = ServerStorage:FindFirstChild("CarTools")
		local tool = CarTools and (CarTools:FindFirstChild(carName) or CarTools:FindFirstChild(carName.." Item"))

		if tool then
			-- üõë SECURE DATASORE WRITE: Lock the purchase ID *before* granting to prevent duping
			-- If the server crashes during grant, it's safer to lose the car than create an infinite duplication glitch.
			local dataSuccess, err = pcall(function()
				PurchaseHistory:SetAsync(purchaseKey, true)
			end)

			if not dataSuccess then
				warn("‚ö†Ô∏è Datastore down. Halting grant to prevent dupe. " .. tostring(err))
				return Enum.ProductPurchaseDecision.NotProcessedYet
			end

			local newTool = tool:Clone()
			newTool:SetAttribute("IssuedByServer", true)
			newTool:SetAttribute("IssuedAt", os.time())
			newTool:SetAttribute("ToolId", tool.Name) 

			-- Give to TARGET PLAYER'S Backpack safely
			local backpack = targetPlayer:FindFirstChild("Backpack")
			if backpack then
				newTool.Parent = backpack
			else
				warn("‚ö†Ô∏è Receiver dead/respawning. Item added to StarterGear only.")
			end

			-- üõë FIX: Safe StarterGear check without infinite yield
			local starterGear = targetPlayer:FindFirstChild("StarterGear")
			if starterGear then
				local gearClone = newTool:Clone()
				gearClone.Parent = starterGear
			end

			-- We handle the success manually here because we already SetAsync
			if isGift then
				print("‚úÖ Gift successfully delivered to " .. targetPlayer.Name)
			end
			return Enum.ProductPurchaseDecision.PurchaseGranted
		else
			warn("‚ùå Critical: Tool missing for Robux Car: " .. carName)
		end
	else
		warn("‚ö†Ô∏è Unknown ProductID Purchased: " .. pid)
	end

	-- ====================================================
	-- üèÅ FINALIZE PURCHASE (For non-car items)
	-- ====================================================
	if purchaseSuccess then
		-- Mark as processed in DataStore so it can't be claimed again
		local dataSuccess, dataErr = pcall(function()
			PurchaseHistory:SetAsync(purchaseKey, true)
		end)

		if not dataSuccess then
			warn("‚ö†Ô∏è Critical Datastore Error saving receipt: " .. tostring(dataErr))
			-- Tell Roblox we failed so they retry the receipt later. 
			-- (Note: For non-car items, this risks double-granting if the DB fails, 
			-- but guarantees they get what they paid for eventually).
			return Enum.ProductPurchaseDecision.NotProcessedYet
		end

		if isGift then
			print("‚úÖ Gift successfully delivered to " .. targetPlayer.Name)
		end

		return Enum.ProductPurchaseDecision.PurchaseGranted
	else
		-- If logic failed (e.g., missing plot), try again later
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end
end
