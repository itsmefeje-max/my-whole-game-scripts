-- Purpose: Centralizes MarketplaceService.ProcessReceipt to handle all product purchases (Cars, Boosts, Skins).
-- Runs on: Server
-- Location: ServerScriptService
-- Dependencies: MarketplaceService, ServerStorage (CarTools), ReplicatedStorage (BaseSkinStats)
-- Public API: MarketplaceService.ProcessReceipt (Callback)
-- Security: Server-side validation, secure asset cloning, ownership attributes, error handling for missing assets.
-- Notes: Fixes a critical crash where buying an item while dead (no Backpack) caused the script to error.

-- [[ SERVER SCRIPT: ReceiptRouter ]]
-- Centralizes MarketplaceService.ProcessReceipt for the entire game.
-- UPDATED: Fixes "Backpack Missing" Crash + Base Skin Support.

local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

-- ‚öôÔ∏è EXISTING PRODUCT IDs
local TABLET_2X_ID = 3509697462 -- Tablet ID
local SHOP_REROLL_ID = 3520990584 -- Reroll ID

-- üöó CAR PRODUCT IDs
local CAR_PRODUCT_IDS = {
	[3524326648] = "Delta",
	[3524327150] = "Iva",
	[3524327478] = "Atom",
	[3524327780] = "Windsor",
	[3524328208] = "Senator",
	[3524328713] = "Riva"
}

-- üîó REFERENCES
local TycoonFolder = Workspace:WaitForChild("Tycoons")
local ShopRerollFunc = ServerStorage:WaitForChild("ShopRerollFunction")

-- ‚úÖ NEW: Base Skin Module Reference
local BaseSkinStats
pcall(function()
	BaseSkinStats = require(ReplicatedStorage:WaitForChild("BaseSkinStats"))
end)

-- ============================================================================
-- üßæ MAIN RECEIPT PROCESSOR
-- ============================================================================
MarketplaceService.ProcessReceipt = function(receiptInfo)
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)

	-- 1. Handle Player Leaving/Crashing
	if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end

	local pid = receiptInfo.ProductId

	print("üõí Processing Purchase for ProductID: " .. pid)

	-- ====================================================
	-- 1Ô∏è‚É£ PRODUCT: TABLET 2X EARNINGS
	-- ====================================================
	if pid == TABLET_2X_ID then
		local myPlotName = player:GetAttribute("OccupiedPlot")
		local plot = myPlotName and TycoonFolder:FindFirstChild(myPlotName)

		-- Retry if plot isn't ready
		if not plot or not plot:FindFirstChild("PendingEarnings") then 
			return Enum.ProductPurchaseDecision.NotProcessedYet 
		end

		local pendingVal = plot.PendingEarnings
		local amount = pendingVal.Value

		-- Logic: Reset pending, add 2x to cash
		if amount > 0 then
			pendingVal.Value = 0
			local ls = player:FindFirstChild("leaderstats")
			if ls and ls:FindFirstChild("Cash") then
				ls.Cash.Value += (amount * 2)
			end
		end
		return Enum.ProductPurchaseDecision.PurchaseGranted

		-- ====================================================
		-- 2Ô∏è‚É£ PRODUCT: SHOP REROLL (Restock)
		-- ====================================================
	elseif pid == SHOP_REROLL_ID then
		if ShopRerollFunc then
			ShopRerollFunc:Invoke(player) 
			return Enum.ProductPurchaseDecision.PurchaseGranted
		else
			warn("‚ö†Ô∏è Critical: ShopRerollFunction missing in ServerStorage!")
			return Enum.ProductPurchaseDecision.NotProcessedYet
		end

		-- ====================================================
		-- 3Ô∏è‚É£ PRODUCT: BASE SKINS (Gold Upgrade) ‚úÖ NEW
		-- ====================================================
	elseif BaseSkinStats then
		-- Search the module to see if this ID matches a skin
		local skinFound = nil
		for name, data in pairs(BaseSkinStats) do
			if data.ProductId == pid then
				skinFound = name
				break
			end
		end

		if skinFound then
			print("üíé Base Skin Purchased: " .. skinFound)

			-- Grant Ownership
			local ownedRaw = player:GetAttribute("OwnedBaseSkins") or "[]"
			local ownedTable = {}
			local success, _ = pcall(function() ownedTable = HttpService:JSONDecode(ownedRaw) end)
			if not success then ownedTable = {} end -- Fallback if decode fails

			if not table.find(ownedTable, skinFound) then
				table.insert(ownedTable, skinFound)
				player:SetAttribute("OwnedBaseSkins", HttpService:JSONEncode(ownedTable))
			end

			-- Auto Equip
			player:SetAttribute("EquippedSkin", skinFound)

			return Enum.ProductPurchaseDecision.PurchaseGranted
		end
	end

	-- ====================================================
	-- 4Ô∏è‚É£ PRODUCT: BUY CAR WITH ROBUX
	-- ====================================================
	-- We check this LAST because it's a generic table lookup
	if CAR_PRODUCT_IDS[pid] then
		local carName = CAR_PRODUCT_IDS[pid]
		local CarTools = ServerStorage:FindFirstChild("CarTools")

		-- Try finding the tool
		local tool = CarTools and (CarTools:FindFirstChild(carName) or CarTools:FindFirstChild(carName.." Item"))

		if tool then
			-- Grant the car
			local newTool = tool:Clone()
			newTool:SetAttribute("IssuedByServer", true)
			newTool:SetAttribute("IssuedAt", os.time())
			newTool:SetAttribute("ToolId", tool.Name) -- Critical for Anti-Cheat

			-- üõ°Ô∏è FIX: SAFE BACKPACK CHECK
			-- If player is dead, Backpack is nil. We skip parenting to Backpack 
			-- and rely on StarterGear to give it to them on respawn.
			local backpack = player:FindFirstChild("Backpack")
			if backpack then
				newTool.Parent = backpack
			else
				warn("‚ö†Ô∏è Player dead/respawning during purchase. Item added to StarterGear only.")
			end

			-- Always add to StarterGear so they keep it after death
			local gearClone = newTool:Clone()
			gearClone.Parent = player:WaitForChild("StarterGear")

			print("‚úÖ Gave Robux Car: " .. carName)
			return Enum.ProductPurchaseDecision.PurchaseGranted
		else
			warn("‚ùå Critical: Tool missing for Robux Car: " .. carName)
			return Enum.ProductPurchaseDecision.NotProcessedYet 
		end
	end

	-- Unknown Product
	warn("‚ö†Ô∏è Unknown ProductID Purchased: " .. pid)
	return Enum.ProductPurchaseDecision.NotProcessedYet
end
