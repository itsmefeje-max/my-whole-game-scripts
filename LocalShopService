-- [[ SERVER SCRIPT: LocalShopService ]]
-- UPDATED: Fixed Currency Target (Now uses 'Wallet' instead of 'Cash')
-- FIXED: Rarity-Based Stock, Optimized Rotation, Boolean Featured Flags
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

-- ‚öôÔ∏è CONFIGURATION
local SHOP_CARS = {"Delta", "Iva", "Atom", "Windsor", "Senator", "Riva"}
-- Weights act as "Rarity %" (Delta = 50% chance to have extra stock)
local CAR_WEIGHTS = {Delta = 50, Iva = 20, Atom = 15, Windsor = 9, Senator = 5, Riva = 1}
local ALWAYS_STOCK = {["Delta"] = true, ["Iva"] = true} 
local RESTOCK_INTERVAL = 300 

-- üìÇ REMOTE SETUP
local Remotes = ReplicatedStorage:FindFirstChild("ShopRemotes")
if not Remotes then
	Remotes = Instance.new("Folder"); Remotes.Name = "ShopRemotes"; Remotes.Parent = ReplicatedStorage
end
local function getRemote(name, class)
	local r = Remotes:FindFirstChild(name)
	if not r then r = Instance.new(class); r.Name = name; r.Parent = Remotes end
	return r
end
local RemoteOpen = getRemote("OpenLocalShop", "RemoteEvent")
local RemoteUpdate = getRemote("ShopUpdate", "RemoteEvent")
local FuncGetState = getRemote("GetShopState", "RemoteFunction")
local FuncBuyCar = getRemote("BuyLocalCar", "RemoteFunction")

-- üîó BINDABLE FUNCTION
local RerollBindable = ServerStorage:FindFirstChild("ShopRerollFunction")
if not RerollBindable then
	RerollBindable = Instance.new("BindableFunction")
	RerollBindable.Name = "ShopRerollFunction"
	RerollBindable.Parent = ServerStorage
end

-- üìÇ DATA
local PlayerSessions = {} 

-- ============================================================================
-- üõ°Ô∏è SECURITY HELPER
-- ============================================================================
local function tagIssued(tool, originalName)
	if not tool then return end
	tool:SetAttribute("IssuedByServer", true)
	tool:SetAttribute("IssuedAt", os.time())
	tool:SetAttribute("IssuedId", HttpService:GenerateGUID(false))
	tool:SetAttribute("ToolId", originalName) -- Crucial for Data Saving
	tool.CanBeDropped = false
end

-- ============================================================================
-- üß† SHOP LOGIC
-- ============================================================================

local function getGlobalSeedID() return math.floor(os.time() / RESTOCK_INTERVAL) end

local function calculateStockForCar(carName, rng)
	local weight = CAR_WEIGHTS[carName] or 0
	local limit = 1 -- Base stock

	-- Roll 1: Chance to get +1 (Based on Rarity %)
	if rng:NextInteger(1, 100) <= weight then
		limit = limit + 1
		-- Roll 2: Small chance to get +1 again (Cap at 3)
		if limit == 2 and rng:NextInteger(1, 100) <= math.ceil(weight * 0.5) then
			limit = limit + 1
		end
	end

	return limit
end

local function generateStockConfiguration(seedValue)
	local rng = Random.new(seedValue)

	local featuredFlags = {} 
	local stockLimits = {}   

	-- 1. Process ALWAYS_STOCK
	for name, _ in pairs(ALWAYS_STOCK) do
		featuredFlags[name] = true
		stockLimits[name] = calculateStockForCar(name, rng)
	end

	-- 2. Build Weighted Pool
	local poolKeys = {}
	local poolWeights = {}
	local totalWeight = 0

	for name, weight in pairs(CAR_WEIGHTS) do
		if not ALWAYS_STOCK[name] then
			table.insert(poolKeys, name)
			totalWeight = totalWeight + weight
			poolWeights[name] = weight
		end
	end

	-- 3. Rotation Logic
	local r = rng:NextInteger(1, 100)
	local targetCount = (r > 90 and 3) or (r > 55 and 2) or 1

	local pickedCount = 0
	local safety = 0

	while pickedCount < targetCount and safety < 50 do
		safety = safety + 1
		local roll = rng:NextInteger(1, totalWeight)
		local current = 0
		local picked = nil

		for _, car in ipairs(poolKeys) do
			local w = poolWeights[car]
			current = current + w
			if roll <= current then
				picked = car
				break
			end
		end

		if picked and not featuredFlags[picked] then
			featuredFlags[picked] = true
			stockLimits[picked] = calculateStockForCar(picked, rng)
			pickedCount = pickedCount + 1
		end
	end

	return { Featured = featuredFlags, Limits = stockLimits }
end

local function calculateCurrentStock(limits, purchasedCounts)
	local current = {}
	for car, limit in pairs(limits) do
		local bought = purchasedCounts[car] or 0
		local left = limit - bought
		if left < 0 then left = 0 end
		current[car] = left
	end
	return current
end

local function validateSession(player)
	local uid = player.UserId
	local currentGlobalID = getGlobalSeedID()

	if not PlayerSessions[uid] then 
		PlayerSessions[uid] = {
			SeedVersion = currentGlobalID, 
			LocalSeed = nil, 
			Purchased = {},
			Cache = nil 
		} 
	end

	local session = PlayerSessions[uid]

	-- RESET IF NEW ROTATION
	if session.SeedVersion ~= currentGlobalID then
		session.SeedVersion = currentGlobalID
		session.LocalSeed = nil
		session.Purchased = {} 
		session.Cache = nil 

		local seed = session.LocalSeed or session.SeedVersion
		session.Cache = generateStockConfiguration(seed)
		local currentStock = calculateCurrentStock(session.Cache.Limits, session.Purchased)

		RemoteUpdate:FireClient(player, {
			Featured = session.Cache.Featured,
			StockLimit = session.Cache.Limits,
			Stock = currentStock,
			Purchased = session.Purchased,
			NextRestock = (currentGlobalID + 1) * RESTOCK_INTERVAL, 
			IsGlobal = true,
			Reason = "Auto"
		})
	end

	if not session.Cache then
		local seed = session.LocalSeed or session.SeedVersion
		session.Cache = generateStockConfiguration(seed)
	end

	return session
end

FuncGetState.OnServerInvoke = function(player)
	local session = validateSession(player)
	local config = session.Cache
	local currentStock = calculateCurrentStock(config.Limits, session.Purchased)

	return {
		Featured = config.Featured,
		StockLimit = config.Limits,
		Stock = currentStock,
		Purchased = session.Purchased,
		NextRestock = (getGlobalSeedID() + 1) * RESTOCK_INTERVAL,
		IsGlobal = (session.LocalSeed == nil)
	}
end

-- ============================================================================
-- üõí BUY CAR (THE FIX IS HERE)
-- ============================================================================
FuncBuyCar.OnServerInvoke = function(player, carName)
	local session = validateSession(player)
	local config = session.Cache

	local CarStats = require(ReplicatedStorage.CarStats)
	local carData = CarStats.Cars[carName]

	if not carData then return false, "Invalid Car" end
	if not config.Featured[carName] then return false, "Not In Rotation" end

	local boughtAmount = session.Purchased[carName] or 0
	local maxLimit = config.Limits[carName]

	if boughtAmount >= maxLimit then
		return false, "Out of Stock"
	end

	-- üî¥ CHANGED HERE: We now check "Wallet" instead of "Cash"
	local wallet = player:FindFirstChild("leaderstats") and player.leaderstats:FindFirstChild("Wallet")
	
	-- Validation
	if not wallet then return false, "Wallet Not Found" end
	if wallet.Value < carData.Price then return false, "Insufficient Cash (Withdraw from ATM)" end

	-- Transaction
	wallet.Value = wallet.Value - carData.Price

	-- üõ†Ô∏è Give Item
	local toolSource = ServerStorage:FindFirstChild("CarTools") and (ServerStorage.CarTools:FindFirstChild(carName) or ServerStorage.CarTools:FindFirstChild(carName.." Item"))

	if toolSource then
		-- 1. Create Backpack Copy
		local backpackTool = toolSource:Clone()
		tagIssued(backpackTool, toolSource.Name)
		backpackTool.Parent = player.Backpack

		-- 2. Create StarterGear Copy
		local gearTool = toolSource:Clone()
		tagIssued(gearTool, toolSource.Name)
		gearTool.Parent = player.StarterGear
	else
		-- Refund if tool is missing
		wallet.Value = wallet.Value + carData.Price 
		return false, "System Error: Tool Missing"
	end

	session.Purchased[carName] = boughtAmount + 1

	-- Update Client
	local currentStock = calculateCurrentStock(config.Limits, session.Purchased)

	RemoteUpdate:FireClient(player, {
		Featured = config.Featured, 
		StockLimit = config.Limits,
		Stock = currentStock,
		Purchased = session.Purchased,
		NextRestock = (getGlobalSeedID() + 1) * RESTOCK_INTERVAL, 
		IsGlobal = (session.LocalSeed == nil),
		Reason = "Purchase"
	})
	return true, "Success"
end

function RerollBindable.OnInvoke(player)
	if not player then return false end
	local session = validateSession(player)

	session.LocalSeed = math.random(1, 999999999)
	session.Purchased = {} 

	session.Cache = generateStockConfiguration(session.LocalSeed)
	local currentStock = calculateCurrentStock(session.Cache.Limits, session.Purchased)

	RemoteUpdate:FireClient(player, {
		Featured = session.Cache.Featured,
		StockLimit = session.Cache.Limits,
		Stock = currentStock,
		Purchased = session.Purchased,
		NextRestock = (getGlobalSeedID() + 1) * RESTOCK_INTERVAL,
		IsGlobal = false,
		Reason = "Reroll"
	})
	return true
end

task.spawn(function()
	local lastGlobalID = getGlobalSeedID()
	while true do
		task.wait(1)
		local currentID = getGlobalSeedID()
		if currentID ~= lastGlobalID then
			lastGlobalID = currentID
			print("üîÑ GLOBAL SHOP ROTATION")
			for _, player in ipairs(Players:GetPlayers()) do validateSession(player) end
		end
	end
end)
Players.PlayerRemoving:Connect(function(player) PlayerSessions[player.UserId] = nil end)
