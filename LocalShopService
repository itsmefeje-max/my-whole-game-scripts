-- [[ SERVER SCRIPT: LocalShopService (Persistence & Dedupe Fixed + Name Mismatch Fixed) ]]
-- Currency: leaderstats.Wallet
-- Global rotation: deterministic per RESTOCK_INTERVAL
-- Local reroll: per-player seed
-- Security: UserId mutex locks, success-only cooldown, pcall wrapper
-- Reliability: Persistence Interface added (Fixes Rejoin Stock Bypass)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

-- =========================
-- CONFIG
-- =========================
local CAR_WEIGHTS = {Delta = 50, Iva = 20, Atom = 15, Windsor = 9, Senator = 5, Riva = 1}
local ALWAYS_STOCK = {Delta = true, Iva = true}

local RESTOCK_INTERVAL = 300
local PURCHASE_COOLDOWN = 0.5

-- =========================
-- MODULES (require once)
-- =========================
local CarStats = require(ReplicatedStorage:WaitForChild("CarStats"))

-- =========================
-- REMOTES
-- =========================
local Remotes = ReplicatedStorage:FindFirstChild("ShopRemotes")
if not Remotes then
	Remotes = Instance.new("Folder")
	Remotes.Name = "ShopRemotes"
	Remotes.Parent = ReplicatedStorage
end

local function getRemote(name, className)
	local r = Remotes:FindFirstChild(name)
	if not r then
		r = Instance.new(className)
		r.Name = name
		r.Parent = Remotes
	end
	return r
end

local RemoteOpen = getRemote("OpenLocalShop", "RemoteEvent")         -- client -> server (optional)
local RemoteUpdate = getRemote("ShopUpdate", "RemoteEvent")          -- server -> client
local FuncGetState = getRemote("GetShopState", "RemoteFunction")     -- client -> server
local FuncBuyCar = getRemote("BuyLocalCar", "RemoteFunction")        -- client -> server

-- =========================
-- BINDABLES (Server Communication)
-- =========================
local RerollBindable = ServerStorage:FindFirstChild("ShopRerollFunction")
if not RerollBindable then
	RerollBindable = Instance.new("BindableFunction")
	RerollBindable.Name = "ShopRerollFunction"
	RerollBindable.Parent = ServerStorage
end

-- âœ… NEW: Persistence Interface for TycoonDataHandler
local PersistenceBindable = ServerStorage:FindFirstChild("ShopPersistenceFunction")
if not PersistenceBindable then
	PersistenceBindable = Instance.new("BindableFunction")
	PersistenceBindable.Name = "ShopPersistenceFunction"
	PersistenceBindable.Parent = ServerStorage
end

-- =========================
-- STATE
-- =========================
local PlayerSessions = {}       -- [userId] = { SeedVersion, LocalSeed, Purchased, Cache }
local PurchaseLocks = {}        -- [userId] = true/nil
local LastPurchaseTime = {}     -- [userId] = os.clock()

-- =========================
-- TOOL TAGGING + PERSISTENT ID
-- =========================
local PERSIST_ID_NAME = "__ShopToolId"

local function setPersistentToolId(tool, toolId)
	tool:SetAttribute("ToolId", toolId)
	local marker = tool:FindFirstChild(PERSIST_ID_NAME)
	if not marker then
		marker = Instance.new("StringValue")
		marker.Name = PERSIST_ID_NAME
		marker.Parent = tool
	end
	marker.Value = toolId
end

local function getPersistentToolId(tool)
	local marker = tool:FindFirstChild(PERSIST_ID_NAME)
	if marker and marker:IsA("StringValue") then
		return marker.Value
	end
	return tool:GetAttribute("ToolId")
end

local function tagIssued(tool, toolId)
	if not tool then return end
	tool:SetAttribute("IssuedByServer", true)
	tool:SetAttribute("IssuedAt", os.time())
	tool:SetAttribute("IssuedId", HttpService:GenerateGUID(false))
	tool.CanBeDropped = false
	setPersistentToolId(tool, toolId)
end

local function starterGearHasToolId(player, toolId)
	local sg = player:FindFirstChild("StarterGear")
	if not sg then return false end
	for _, child in ipairs(sg:GetChildren()) do
		if getPersistentToolId(child) == toolId then
			return true
		end
	end
	return false
end

-- =========================
-- SHOP LOGIC
-- =========================
local function getGlobalSeedID()
	return math.floor(os.time() / RESTOCK_INTERVAL)
end

local function calculateStockForCar(carName, rng)
	local weight = CAR_WEIGHTS[carName] or 0
	local limit = 1
	if rng:NextInteger(1, 100) <= weight then
		limit += 1
		if limit == 2 and rng:NextInteger(1, 100) <= math.ceil(weight * 0.5) then
			limit += 1
		end
	end
	return limit
end

local function generateStockConfiguration(seedValue)
	local rng = Random.new(seedValue)
	local featuredFlags = {}
	local stockLimits = {}

	for name in pairs(ALWAYS_STOCK) do
		featuredFlags[name] = true
		stockLimits[name] = calculateStockForCar(name, rng)
	end

	local poolKeys = {}
	local poolWeights = {}
	local totalWeight = 0
	for name, weight in pairs(CAR_WEIGHTS) do
		if not ALWAYS_STOCK[name] then
			table.insert(poolKeys, name)
			poolWeights[name] = weight
			totalWeight += weight
		end
	end

	if totalWeight <= 0 or #poolKeys == 0 then
		return { Featured = featuredFlags, Limits = stockLimits }
	end

	local r = rng:NextInteger(1, 100)
	local targetCount = (r > 90 and 3) or (r > 55 and 2) or 1
	local pickedCount = 0
	local safety = 0

	while pickedCount < targetCount and safety < 50 do
		safety += 1
		local roll = rng:NextInteger(1, totalWeight)
		local current = 0
		local picked = nil
		for _, car in ipairs(poolKeys) do
			current += poolWeights[car]
			if roll <= current then
				picked = car
				break
			end
		end

		if picked and not featuredFlags[picked] then
			featuredFlags[picked] = true
			stockLimits[picked] = calculateStockForCar(picked, rng)
			pickedCount += 1
		end
	end

	return { Featured = featuredFlags, Limits = stockLimits }
end

local function calculateCurrentStock(limits, purchasedCounts)
	local current = {}
	for car, limit in pairs(limits) do
		local bought = purchasedCounts[car] or 0
		local left = limit - bought
		if left < 0 then left = 0 end
		current[car] = left
	end
	return current
end

local function getSession(player)
	local uid = player.UserId
	local currentGlobalID = getGlobalSeedID()

	if not PlayerSessions[uid] then
		PlayerSessions[uid] = {
			SeedVersion = currentGlobalID,
			LocalSeed = nil,
			Purchased = {},
			Cache = nil,
		}
	end

	local session = PlayerSessions[uid]
	local didReset = false

	if session.SeedVersion ~= currentGlobalID then
		session.SeedVersion = currentGlobalID
		session.LocalSeed = nil
		session.Purchased = {} -- Reset purchases on new rotation
		session.Cache = generateStockConfiguration(session.SeedVersion)
		didReset = true
	end

	if not session.Cache then
		local seed = session.LocalSeed or session.SeedVersion
		session.Cache = generateStockConfiguration(seed)
	end

	return session, didReset
end

local function buildStatePayload(session)
	local config = session.Cache
	local currentStock = calculateCurrentStock(config.Limits, session.Purchased)
	return {
		Featured = config.Featured,
		StockLimit = config.Limits,
		Stock = currentStock,
		Purchased = session.Purchased,
		NextRestock = (getGlobalSeedID() + 1) * RESTOCK_INTERVAL,
		IsGlobal = (session.LocalSeed == nil),
	}
end

local function pushUpdate(player, session, reason)
	local payload = buildStatePayload(session)
	payload.Reason = reason
	RemoteUpdate:FireClient(player, payload)
end

-- =========================
-- DATA HANDLER INTEGRATION
-- =========================
-- TycoonDataHandler calls this via BindableFunction
PersistenceBindable.OnInvoke = function(action, player, data)
	if not player then return end
	local uid = player.UserId

	if action == "Load" then
		-- RESTORE purchased counts from DataStore
		local session, _ = getSession(player)
		if data and type(data) == "table" then
			-- Only restore if rotation matches (prevents loading old purchases for new rotation)
			-- NOTE: To be safe, we just load it. getSession checks rotation anyway next time it's called.
			session.Purchased = data
			print("âœ… [Shop] Loaded purchases for " .. player.Name)
		end

	elseif action == "Get" then
		-- RETURN purchased counts to be saved
		if PlayerSessions[uid] then
			return PlayerSessions[uid].Purchased
		end
		return {}

	elseif action == "Close" then
		-- CLEANUP after save is complete
		PlayerSessions[uid] = nil
		PurchaseLocks[uid] = nil
		LastPurchaseTime[uid] = nil
	end
end

-- =========================
-- CLIENT REQUESTS
-- =========================
FuncGetState.OnServerInvoke = function(player)
	local session, didReset = getSession(player)
	return buildStatePayload(session)
end

RemoteOpen.OnServerEvent:Connect(function(player)
	local session = getSession(player)
	pushUpdate(player, session, "Open")
end)

FuncBuyCar.OnServerInvoke = function(player, carName)
	if typeof(carName) ~= "string" then return false, "Invalid Car" end
	if not player or not player.Parent then return false, "Player missing" end

	local uid = player.UserId
	if PurchaseLocks[uid] then return false, "Purchase in progress" end
	if (os.clock() - (LastPurchaseTime[uid] or 0)) < PURCHASE_COOLDOWN then return false, "Slow down" end

	PurchaseLocks[uid] = true

	local pOk, logicOk, msg = pcall(function()
		local session, didReset = getSession(player)
		if didReset then pushUpdate(player, session, "Auto") end

		local config = session.Cache
		local carsTable = CarStats and CarStats.Cars
		if not carsTable then return false, "CarStats Error" end

		local carData = carsTable[carName]
		if not carData or not config.Featured[carName] then return false, "Invalid Car" end

		local bought = session.Purchased[carName] or 0
		local limit = config.Limits[carName] or 0
		if bought >= limit then return false, "Out of Stock" end

		-- Currency: WALLET
		local ls = player:FindFirstChild("leaderstats")
		local wallet = ls and ls:FindFirstChild("Wallet")
		if not wallet then return false, "Wallet Not Found" end
		if wallet.Value < carData.Price then return false, "Insufficient Cash (Withdraw from ATM)" end

		-- Tool Check
		local toolsFolder = ServerStorage:FindFirstChild("CarTools")
		local toolSource = toolsFolder and (toolsFolder:FindFirstChild(carName) or toolsFolder:FindFirstChild(carName .. " Item"))
		if not toolSource then return false, "System Error: Tool Missing" end

		-- Transaction
		wallet.Value -= carData.Price

		-- [[ CRITICAL FIX ]] 
		-- Capture the exact Name from ServerStorage (e.g., "Delta Item")
		-- We use THIS name for the persistent ID so TycoonDataHandler finds it later.
		local realToolName = toolSource.Name 

		-- Grant Tool (Backpack)
		local backpack = player:FindFirstChildOfClass("Backpack")
		if backpack then
			local backpackTool = toolSource:Clone()
			tagIssued(backpackTool, realToolName) -- âœ… Uses "Delta Item"
			backpackTool.Parent = backpack
		end

		-- Grant Tool (StarterGear) - DEDUPLICATED
		local sg = player:FindFirstChild("StarterGear")
		if sg and not starterGearHasToolId(player, realToolName) then
			local gearTool = toolSource:Clone()
			tagIssued(gearTool, realToolName) -- âœ… Uses "Delta Item"
			gearTool.Parent = sg
		end

		-- Update State
		session.Purchased[carName] = bought + 1
		pushUpdate(player, session, "Purchase")

		return true, "Success"
	end)

	PurchaseLocks[uid] = nil

	if not pOk then
		warn("Shop Buy Error:", logicOk)
		return false, "Internal System Error"
	end

	if logicOk then LastPurchaseTime[uid] = os.clock() end
	return logicOk, msg
end

-- =========================
-- REROLL
-- =========================
function RerollBindable.OnInvoke(player)
	if not player or not player.Parent then return false end
	local session = getSession(player)
	session.LocalSeed = math.random(1, 999999999)
	session.Purchased = {}
	session.Cache = generateStockConfiguration(session.LocalSeed)
	pushUpdate(player, session, "Reroll")
	return true
end

-- =========================
-- ROTATION LOOP
-- =========================
task.spawn(function()
	local lastGlobalID = getGlobalSeedID()
	while true do
		task.wait(1)
		local currentID = getGlobalSeedID()
		if currentID ~= lastGlobalID then
			lastGlobalID = currentID
			print("ðŸ”„ GLOBAL SHOP ROTATION")
			for _, player in ipairs(Players:GetPlayers()) do
				local session, didReset = getSession(player)
				if didReset then pushUpdate(player, session, "Auto") end
			end
		end
	end
end)

-- Note: Session cleanup is now handled via "Close" action in PersistenceBindable
-- This ensures data isn't wiped before TycoonDataHandler saves it.
